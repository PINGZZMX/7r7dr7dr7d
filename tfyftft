import ctypes
import cv2
import json
import math
import mss
import os
import sys
import time
import torch
import numpy as np
import uuid
import win32api
import win32gui
import win32con
from termcolor import colored
from ultralytics import YOLO

# Function to get the base directory
def get_base_dir():
    if getattr(sys, 'frozen', False):
        # We are running as a bundle
        return os.path.dirname(sys.executable)
    else:
        # We are running as a regular Python script
        return os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Auto Screen Resolution
screensize = {'X': ctypes.windll.user32.GetSystemMetrics(0), 'Y': ctypes.windll.user32.GetSystemMetrics(1)}

# If you use stretched res, hardcode the X and Y. For example: screen_res_x = 1234
screen_res_x = screensize['X']
screen_res_y = screensize['Y']

# Divide screen_res by 2
# No need to change this
screen_x = int(screen_res_x / 2)
screen_y = int(screen_res_y / 2)

aim_height = 10 # The lower the number, the higher the aim_height. For example: 2 would be the head and 100 would be the feet.

fov = 350

confidence = 0.45 # How confident the AI needs to be for it to lock on to the player. Default is 45%

use_trigger_bot = True # Will shoot if crosshair is locked on the player

PUL = ctypes.POINTER(ctypes.c_ulong)
class KeyBdInput(ctypes.Structure):
    _fields_ = [("wVk", ctypes.c_ushort),
                ("wScan", ctypes.c_ushort),
                ("dwFlags", ctypes.c_ulong),
                ("time", ctypes.c_ulong),
                ("dwExtraInfo", PUL)]

class HardwareInput(ctypes.Structure):
    _fields_ = [("uMsg", ctypes.c_ulong),
                ("wParamL", ctypes.c_short),
                ("wParamH", ctypes.c_ushort)]

class MouseInput(ctypes.Structure):
    _fields_ = [("dx", ctypes.c_long),
                ("dy", ctypes.c_long),
                ("mouseData", ctypes.c_ulong),
                ("dwFlags", ctypes.c_ulong),
                ("time", ctypes.c_ulong),
                ("dwExtraInfo", PUL)]

class Input_I(ctypes.Union):
    _fields_ = [("ki", KeyBdInput),
                ("mi", MouseInput),
                ("hi", HardwareInput)]

class Input(ctypes.Structure):
    _fields_ = [("type", ctypes.c_ulong),
                ("ii", Input_I)]

class POINT(ctypes.Structure):
    _fields_ = [("x", ctypes.c_long), ("y", ctypes.c_long)]


class Aimbot:
    extra = ctypes.c_ulong(0)
    ii_ = Input_I()
    screen = mss.mss()
    pixel_increment = 1 #controls how many pixels the mouse moves for each relative movement
    
    # Set up config path
    base_dir = get_base_dir()
    config_path = os.path.join(base_dir, "lib", "config", "config.json")
    
    with open(config_path) as f:
        sens_config = json.load(f)
    aimbot_status = colored("ENABLED", 'green')

    def __init__(self, box_constant = fov, collect_data = False, mouse_delay = 0.0009):
        #controls the initial centered box width and height of the "Pinguin Development" window
        self.box_constant = box_constant #controls the size of the detection box (equaling the width and height)

        print("[INFO] Loading the neural network model")
        self.base_dir = get_base_dir()
        self.model = YOLO(os.path.join(self.base_dir, 'lib', 'best.pt'))
        if torch.cuda.is_available():
            print(colored("CUDA ACCELERATION [ENABLED]", "green"))
        else:
            print(colored("[!] CUDA ACCELERATION IS UNAVAILABLE", "red"))
            print(colored("[!] Check your PyTorch installation, else performance will be poor", "red"))

        self.conf = confidence # base confidence threshold (or base detection (0-1)
        self.iou = 0.45 # NMS IoU (0-1)
        self.collect_data = collect_data
        self.mouse_delay = mouse_delay
        
        # Load aimbot sensitivity from config
        self.aimbot_sensitivity = Aimbot.sens_config.get('aimbot_sens', 1.0)

        print("\n[INFO] PRESS 'F1' TO TOGGLE AIMBOT\n[INFO] PRESS 'F2' TO QUIT\n[INFO] PRESS 'F3' TO EDIT AIMBOT SENSITIVITY")
        print("[INFO] PRESS 'F4' TO EDIT AI CONFIDENCE\n[INFO] PRESS 'F5' TO EDIT FOV\n")

    def set_sensitivity(self, new_sensitivity):
        """Update aimbot sensitivity during runtime"""
        self.aimbot_sensitivity = new_sensitivity
        print(colored(f"\n[INFO] Aimbot sensitivity updated to: {new_sensitivity}", "green"))

    def set_confidence(self, new_confidence):
        """Update AI confidence during runtime"""
        self.conf = new_confidence
        print(colored(f"\n[INFO] AI confidence updated to: {new_confidence}", "green"))

    def set_fov(self, new_fov):
        """Update FOV during runtime"""
        self.box_constant = new_fov
        print(colored(f"\n[INFO] FOV updated to: {new_fov}", "green"))

    @staticmethod
    def update_status_aimbot():
        if Aimbot.aimbot_status == colored("ENABLED", 'green'):
            Aimbot.aimbot_status = colored("DISABLED", 'red')
        else:
            Aimbot.aimbot_status = colored("ENABLED", 'green')
        sys.stdout.write("\033[K")
        print(f"[!] AIMBOT IS [{Aimbot.aimbot_status}]", end = "\r")

    @staticmethod
    def left_click():
        ctypes.windll.user32.mouse_event(0x0002) #left mouse down
        Aimbot.sleep(0.0001)
        ctypes.windll.user32.mouse_event(0x0004) #left mouse up

    @staticmethod
    def sleep(duration, get_now = time.perf_counter):
        if duration == 0: return
        now = get_now()
        end = now + duration
        while now < end:
            now = get_now()

    @staticmethod
    def is_aimbot_enabled():
        return Aimbot.aimbot_status == colored("ENABLED", 'green')

    @staticmethod
    def is_shooting():
        return win32api.GetKeyState(0x01) in (-127, -128)
    
    @staticmethod
    def is_targeted():
        return win32api.GetKeyState(0x02) in (-127, -128)

    @staticmethod
    def is_target_locked(x, y):
        #plus/minus 5 pixel threshold
        threshold = 5
        return screen_x - threshold <= x <= screen_x + threshold and screen_y - threshold <= y <= screen_y + threshold

    def move_crosshair(self, x, y):
        if not Aimbot.is_targeted():
            return

        # Calculate the relative movement
        diff_x = x - screen_x
        diff_y = y - screen_y
        
        # Apply aimbot sensitivity
        rel_x = int(diff_x * self.aimbot_sensitivity)
        rel_y = int(diff_y * self.aimbot_sensitivity)
        
        # Only move if there's a significant movement needed
        if abs(rel_x) > 0 or abs(rel_y) > 0:
            Aimbot.ii_.mi = MouseInput(rel_x, rel_y, 0, 0x0001, 0, ctypes.pointer(Aimbot.extra))
            input_obj = Input(ctypes.c_ulong(0), Aimbot.ii_)
            ctypes.windll.user32.SendInput(1, ctypes.byref(input_obj), ctypes.sizeof(input_obj))

    def start(self):
        print("[INFO] Beginning screen capture")
        Aimbot.update_status_aimbot()
        half_screen_width = ctypes.windll.user32.GetSystemMetrics(0)/2
        half_screen_height = ctypes.windll.user32.GetSystemMetrics(1)/2
        detection_box = {'left': int(half_screen_width - self.box_constant//2), #x1 coord (for top-left corner of the box)
                          'top': int(half_screen_height - self.box_constant//2), #y1 coord (for top-left corner of the box)
                          'width': int(self.box_constant),  #width of the box
                          'height': int(self.box_constant)} #height of the box

        # Create window with proper flags for optimization
        cv2.namedWindow("Pinguin Development", cv2.WINDOW_NORMAL | cv2.WINDOW_KEEPRATIO)
        
        # Set window to always on top
        hwnd = win32gui.FindWindow(None, "Pinguin Development")
        if hwnd:
            win32gui.SetWindowPos(hwnd, win32con.HWND_TOPMOST, 0, 0, 0, 0, 
                                win32con.SWP_NOMOVE | win32con.SWP_NOSIZE)

        # FPS optimization variables
        frame_count = 0
        last_fps_time = time.time()
        current_fps = 0
        
        # Pre-allocate frame for better memory management
        frame_buffer = None

        while True:
            start_time = time.perf_counter()
            # Update detection box size if FOV was changed
            detection_box = {'left': int(half_screen_width - self.box_constant//2), 
                             'top': int(half_screen_height - self.box_constant//2), 
                             'width': int(self.box_constant),  
                             'height': int(self.box_constant)} 
            
            initial_frame = Aimbot.screen.grab(detection_box)
            frame = np.array(initial_frame, dtype=np.uint8)
            if frame is None or frame.size == 0:
                continue
            frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2BGR)
            
            # Run inference on smaller resolution for speed
            inference_scale = 0.5 if self.box_constant > 400 else 1.0
            if inference_scale < 1.0:
                small_frame = cv2.resize(frame, None, fx=inference_scale, fy=inference_scale)
                boxes = self.model.predict(source=small_frame, verbose=False, conf=self.conf, iou=self.iou, half=True)
            else:
                boxes = self.model.predict(source=frame, verbose=False, conf=self.conf, iou=self.iou, half=True)
            
            result = boxes[0]
            if len(result.boxes.xyxy) != 0: #player detected
                least_crosshair_dist = closest_detection = player_in_frame = False
                for box in result.boxes.xyxy: #iterate over each player detected
                    x1, y1, x2, y2 = map(int, box)
                    
                    # Scale coordinates back if inference was done on smaller frame
                    if inference_scale < 1.0:
                        x1, y1, x2, y2 = int(x1/inference_scale), int(y1/inference_scale), int(x2/inference_scale), int(y2/inference_scale)
                    
                    x1y1 = (x1, y1)
                    x2y2 = (x2, y2)
                    height = y2 - y1
                    relative_head_X, relative_head_Y = int((x1 + x2)/2), int((y1 + y2)/2 - height/aim_height) # offset to roughly approximate the head using a ratio of the height
                    own_player = x1 < 15 or (x1 < self.box_constant/5 and y2 > self.box_constant/1.2) # helps ensure that your own player is not regarded as a valid detection

                    #calculate the distance between each detection and the crosshair at (self.box_constant/2, self.box_constant/2)
                    crosshair_dist = math.dist((relative_head_X, relative_head_Y), (self.box_constant/2, self.box_constant/2))

                    if not least_crosshair_dist: least_crosshair_dist = crosshair_dist #initalize least crosshair distance variable first iteration

                    if crosshair_dist <= least_crosshair_dist and not own_player:
                        least_crosshair_dist = crosshair_dist
                        closest_detection = {"x1y1": x1y1, "x2y2": x2y2, "relative_head_X": relative_head_X, "relative_head_Y": relative_head_Y}

                    if own_player:
                        own_player = False
                        if not player_in_frame:
                            player_in_frame = True

                if closest_detection: #if valid detection exists
                    cv2.circle(frame, (closest_detection["relative_head_X"], closest_detection["relative_head_Y"]), 5, (115, 244, 113), -1) #draw circle on the head

                    #draw line from the crosshair to the head
                    cv2.line(frame, (closest_detection["relative_head_X"], closest_detection["relative_head_Y"]), (self.box_constant//2, self.box_constant//2), (244, 242, 113), 2)

                    absolute_head_X, absolute_head_Y = closest_detection["relative_head_X"] + detection_box['left'], closest_detection["relative_head_Y"] + detection_box['top']
                    x1, y1 = closest_detection["x1y1"]

                    if Aimbot.is_target_locked(absolute_head_X, absolute_head_Y):
                        if use_trigger_bot and not Aimbot.is_shooting():
                            Aimbot.left_click()

                        cv2.putText(frame, "LOCKED", (x1 + 40, y1), cv2.FONT_HERSHEY_DUPLEX, 0.5, (115, 244, 113), 2) #draw the confidence labels on the bounding boxes
                    else:
                        cv2.putText(frame, "TARGETING", (x1 + 40, y1), cv2.FONT_HERSHEY_DUPLEX, 0.5, (115, 113, 244), 2) #draw the confidence labels on the bounding boxes

                    if Aimbot.is_aimbot_enabled():
                        self.move_crosshair(absolute_head_X, absolute_head_Y)

            # Efficient FPS calculation (update every 10 frames)
            frame_count += 1
            if frame_count % 10 == 0:
                current_time = time.time()
                time_diff = current_time - last_fps_time
                if time_diff > 0:
                    current_fps = frame_count / time_diff
                frame_count = 0
                last_fps_time = current_time

            # Display current settings
            cv2.putText(frame, f"Pinguin Development", (5, 30), cv2.FONT_HERSHEY_DUPLEX, 0.7, (80, 200, 80), 1)
            cv2.putText(frame, f"FPS: {int(current_fps)}", (5, 60), cv2.FONT_HERSHEY_DUPLEX, 0.7, (113, 116, 244), 1)
            cv2.putText(frame, f"Sens: {self.aimbot_sensitivity:.1f}", (5, 90), cv2.FONT_HERSHEY_DUPLEX, 0.7, (113, 116, 244), 1)
            cv2.putText(frame, f"Conf: {self.conf:.2f}", (5, 120), cv2.FONT_HERSHEY_DUPLEX, 0.7, (113, 116, 244), 1)
            cv2.putText(frame, f"FOV: {self.box_constant}", (5, 150), cv2.FONT_HERSHEY_DUPLEX, 0.7, (113, 116, 244), 1)
            
            # Use faster window update method
            cv2.imshow("Pinguin Development", frame)
            if cv2.waitKey(1) & 0xFF == ord('0'):
                break

    @staticmethod
    def clean_up():
        print("\n[INFO] F2 WAS PRESSED. QUITTING...")
        Aimbot.screen.close()
        os._exit(0)

if __name__ == "__main__": print("You are in the wrong directory and are running the wrong file; you must run pinguin.py")
